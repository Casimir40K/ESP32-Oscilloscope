// ============================
//     Oscilloscope v2.2
//     Enhanced with Signal Generator
// ============================

  #include <WiFi.h>
  #include <WebServer.h>
  #include "chartjs_umd.h"

// ----------------------------
//        CONFIGURATION
// ----------------------------
  const char* ssid = "CasimirServer";
  const char* password = "CasimirServer";
  const char* ap_ssid = "ESP32-Oscilloscope";
  const char* ap_password = "12345678";

  #define NUM_CHANNELS 6
  #define MAX_SAMPLES 500  // Maximum buffer size
  #define LED_PIN 2
  const int analogPins[NUM_CHANNELS] = {34, 35, 32, 33, 36, 39};
  const int triggerPin = 27;  // Note: Will be reconfigured as output for signal generation
  const int signalPin = 27;   // GPIO27 for signal generation

// ----------------------------
//    ADJUSTABLE PARAMETERS
// ----------------------------
  struct SamplingConfig {
    int numSamples = 100;           // Number of samples per capture (10-500)
    int sampleRateUs = 100;         // Microseconds between samples (10-10000)
    int channelDelayUs = 5;         // Microseconds between channel reads (1-100)
    int captureIntervalMs = 50;     // Milliseconds between captures in continuous mode (10-5000)
    int webUpdateMs = 500;          // Milliseconds between web updates (100-5000)
  } samplingConfig;

  struct SignalConfig {
    int waveformType = 0;           // 0=DC, 1=Square, 2=Sine, 3=Triangle, 4=PWM
    int amplitude = 255;            // DAC value (0-255, ~0-3.3V)
    int frequency = 1000;           // Frequency in Hz (1-50000)
    int pulseWidthMs = 100;         // Pulse width in ms for single pulse (1-10000)
    int dutyCycle = 50;             // Duty cycle percentage for PWM (1-99)
    bool isEnabled = false;         // Signal generator on/off
    bool singlePulse = false;       // Single pulse mode
    int dcOffset = 128;             // DC offset for AC waveforms (0-255)
  } signalConfig;

  // Presets for common use cases
  struct Preset {
    const char* name;
    int samples;
    int sampleRate;
    int channelDelay;
    int captureInterval;
    int webUpdate;
  };

  const Preset presets[] = {
    {"High Speed", 100, 10, 1, 20, 200},      // Fast sampling, low resolution
    {"Balanced", 200, 100, 5, 50, 500},       // Default balanced settings
    {"High Resolution", 500, 1000, 10, 200, 1000}, // Slower but more detailed
    {"Low Power", 50, 5000, 20, 1000, 2000}   // Power saving mode
  };
  const int numPresets = sizeof(presets) / sizeof(presets[0]);

  // Signal generator presets
  struct SignalPreset {
    const char* name;
    int waveform;
    int amplitude;
    int frequency;
    int dutyCycle;
    int dcOffset;
  };

  const SignalPreset signalPresets[] = {
    {"1kHz Square", 1, 255, 1000, 50, 128},     // 1kHz square wave
    {"10kHz Sine", 2, 200, 10000, 50, 128},     // 10kHz sine wave
    {"PWM 25%", 4, 255, 1000, 25, 0},           // PWM 25% duty cycle
    {"Test Signal", 1, 128, 100, 50, 64},       // Low amplitude test
    {"DC 1.65V", 0, 128, 0, 0, 128}             // DC voltage reference
  };
  const int numSignalPresets = sizeof(signalPresets) / sizeof(signalPresets[0]);

// ----------------------------
//         GLOBALS
// ----------------------------
  int waveformData[NUM_CHANNELS][MAX_SAMPLES];
  bool wifiConnected = false;
  bool apStarted = false;
  bool isSnapshotMode = false;
  bool triggerPressed = false;
  unsigned long previousMillis = 0;
  unsigned long lastWebUpdate = 0;
  unsigned long lastCapture = 0;
  unsigned long signalLastUpdate = 0;
  unsigned long pulseStartTime = 0;
  bool pulseActive = false;
  float signalPhase = 0.0;
  const long blinkInterval = 500;

  WebServer server(80);

// ----------------------------
//   SIGNAL GENERATION
// ----------------------------
  void updateSignalOutput() {
    if (!signalConfig.isEnabled) {
      dacWrite(signalPin, 0);
      return;
    }

    unsigned long currentMicros = micros();
    
    // Handle single pulse mode
    if (signalConfig.singlePulse) {
      if (pulseActive) {
        if (millis() - pulseStartTime >= signalConfig.pulseWidthMs) {
          pulseActive = false;
          signalConfig.isEnabled = false;
          signalConfig.singlePulse = false;
          dacWrite(signalPin, 0);
          return;
        }
        dacWrite(signalPin, signalConfig.amplitude);
      }
      return;
    }

    // Calculate time-based parameters
    float periodUs = 1000000.0 / signalConfig.frequency;
    float timeInPeriod = fmod(currentMicros, periodUs);
    float normalizedTime = timeInPeriod / periodUs; // 0.0 to 1.0
    
    int outputValue = 0;
    
    switch (signalConfig.waveformType) {
      case 0: // DC
        outputValue = signalConfig.amplitude;
        break;
        
      case 1: // Square Wave
        outputValue = (normalizedTime < 0.5) ? signalConfig.amplitude : 0;
        outputValue += signalConfig.dcOffset;
        break;
        
      case 2: // Sine Wave
        {
          float sineValue = sin(2 * PI * normalizedTime);
          outputValue = signalConfig.dcOffset + (signalConfig.amplitude * sineValue / 2);
        }
        break;
        
      case 3: // Triangle Wave
        {
          float triangleValue;
          if (normalizedTime < 0.5) {
            triangleValue = 4 * normalizedTime - 1; // -1 to 1
          } else {
            triangleValue = 3 - 4 * normalizedTime; // 1 to -1
          }
          outputValue = signalConfig.dcOffset + (signalConfig.amplitude * triangleValue / 2);
        }
        break;
        
      case 4: // PWM
        {
          float dutyCycleNorm = signalConfig.dutyCycle / 100.0;
          outputValue = (normalizedTime < dutyCycleNorm) ? signalConfig.amplitude : 0;
        }
        break;
    }
    
    // Clamp output to valid DAC range
    outputValue = constrain(outputValue, 0, 255);
    dacWrite(signalPin, outputValue);
  }

  void startSinglePulse() {
    signalConfig.singlePulse = true;
    signalConfig.isEnabled = true;
    pulseStartTime = millis();
    pulseActive = true;
  }

// ----------------------------
//      HTML Page String 
// ----------------------------
  const char htmlPage[] PROGMEM = R"rawliteral(
  <!DOCTYPE html>
  <html>
  <head>
    <title>ESP32 Oscilloscope & Signal Generator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      body { 
        font-family: Arial; 
        background-color: #1e1e1e; 
        color: white; 
        margin: 0; 
        padding: 20px; 
        text-align: center; 
      }
      canvas { 
        background: #2e2e2e; 
        border: 1px solid #444; 
        margin: 20px auto; 
        display: block;
        width: 95% !important;
        max-width: 1200px;
        height: 40vh !important;
        min-height: 250px;
        max-height: 400px;
      }
      button { 
        margin: 5px; 
        padding: 8px 16px; 
        font-size: 14px; 
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      button:hover { background-color: #45a049; }
      button.preset { background-color: #2196F3; }
      button.preset:hover { background-color: #1976D2; }
      button.signal-on { background-color: #f44336; }
      button.signal-on:hover { background-color: #d32f2f; }
      button.pulse { background-color: #ff9800; }
      button.pulse:hover { background-color: #f57c00; }
      
      .controls {
        margin: 15px 0;
        display: flex;
        justify-content: center;
        gap: 8px;
        flex-wrap: wrap;
      }
      .status {
        margin: 10px;
        padding: 10px;
        background-color: #333;
        border-radius: 4px;
        display: flex;
        justify-content: center;
        gap: 20px;
        flex-wrap: wrap;
      }
      .settings {
        background-color: #2a2a2a;
        border: 1px solid #444;
        border-radius: 8px;
        padding: 15px;
        margin: 15px auto;
        max-width: 800px;
        text-align: left;
      }
      .setting-row {
        display: flex;
        align-items: center;
        margin: 8px 0;
        gap: 10px;
        flex-wrap: wrap;
      }
      .setting-row label {
        min-width: 120px;
        font-weight: bold;
      }
      .setting-row input, .setting-row select {
        background-color: #444;
        border: 1px solid #666;
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        width: 80px;
      }
      .legend { 
        margin-top: 10px; 
        font-size: 13px;
      }
      .presets {
        margin: 10px 0;
      }
      .signal-status {
        background-color: #2a4a2a;
        border: 2px solid #4CAF50;
        border-radius: 8px;
        padding: 10px;
        margin: 10px auto;
        max-width: 600px;
      }
      .signal-status.active {
        background-color: #4a2a2a;
        border-color: #f44336;
        animation: pulse 1s infinite;
      }
      @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.7; }
        100% { opacity: 1; }
      }
      .two-column {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin: 20px 0;
      }
      @media (max-width: 768px) {
        .two-column {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <h2>ESP32 Oscilloscope & Signal Generator</h2>
    
    <div class="status">
      <span>Scope Mode: <span id="modeStatus">Continuous</span></span>
      <span>Status: <span id="connectionStatus">Loading...</span></span>
      <span>Samples: <span id="currentSamples">100</span></span>
      <span>Rate: <span id="currentRate">100µs</span></span>
    </div>
    
    <div class="signal-status" id="signalStatus">
      <strong>Signal Generator:</strong> 
      <span id="signalState">OFF</span> | 
      <span id="signalInfo">DC 0V</span>
    </div>
    
    <div class="controls">
      <button onclick="toggleMode()">Toggle Scope Mode</button>
      <button onclick="captureWaveform()">Manual Capture</button>
      <button onclick="clearChart()">Clear Chart</button>
      <button onclick="toggleSettings()">Settings</button>
      <button onclick="toggleSignalSettings()">Signal Generator</button>
    </div>
    
    <div class="two-column">
      <div id="settingsPanel" class="settings" style="display: none;">
        <h3>Oscilloscope Configuration</h3>
        
        <div class="presets">
          <strong>Quick Presets:</strong><br>
          <button class="preset" onclick="applyPreset(0)">High Speed</button>
          <button class="preset" onclick="applyPreset(1)">Balanced</button>
          <button class="preset" onclick="applyPreset(2)">High Resolution</button>
          <button class="preset" onclick="applyPreset(3)">Low Power</button>
        </div>
        
        <div class="setting-row">
          <label>Samples:</label>
          <input type="number" id="numSamples" min="10" max="500" value="100">
          <span>(10-500)</span>
        </div>
        
        <div class="setting-row">
          <label>Sample Rate:</label>
          <input type="number" id="sampleRate" min="10" max="10000" value="100">
          <span>µs (10-10000)</span>
        </div>
        
        <div class="setting-row">
          <label>Channel Delay:</label>
          <input type="number" id="channelDelay" min="1" max="100" value="5">
          <span>µs (1-100)</span>
        </div>
        
        <div class="setting-row">
          <label>Capture Interval:</label>
          <input type="number" id="captureInterval" min="10" max="5000" value="50">
          <span>ms (10-5000)</span>
        </div>
        
        <div class="setting-row">
          <label>Web Update:</label>
          <input type="number" id="webUpdate" min="100" max="5000" value="500">
          <span>ms (100-5000)</span>
        </div>
        
        <div class="setting-row">
          <button onclick="applySettings()">Apply Settings</button>
          <button onclick="resetToDefaults()">Reset Defaults</button>
        </div>
      </div>

      <div id="signalPanel" class="settings" style="display: none;">
        <h3>Signal Generator (GPIO27)</h3>
        
        <div class="presets">
          <strong>Signal Presets:</strong><br>
          <button class="preset" onclick="applySignalPreset(0)">1kHz Square</button>
          <button class="preset" onclick="applySignalPreset(1)">10kHz Sine</button>
          <button class="preset" onclick="applySignalPreset(2)">PWM 25%</button>
          <button class="preset" onclick="applySignalPreset(3)">Test Signal</button>
          <button class="preset" onclick="applySignalPreset(4)">DC 1.65V</button>
        </div>
        
        <div class="setting-row">
          <label>Waveform:</label>
          <select id="waveformType">
            <option value="0">DC</option>
            <option value="1">Square</option>
            <option value="2">Sine</option>
            <option value="3">Triangle</option>
            <option value="4">PWM</option>
          </select>
        </div>
        
        <div class="setting-row">
          <label>Amplitude:</label>
          <input type="number" id="amplitude" min="0" max="255" value="128">
          <span>(0-255, ~0-3.3V)</span>
        </div>
        
        <div class="setting-row">
          <label>Frequency:</label>
          <input type="number" id="frequency" min="1" max="50000" value="1000">
          <span>Hz (1-50000)</span>
        </div>
        
        <div class="setting-row">
          <label>DC Offset:</label>
          <input type="number" id="dcOffset" min="0" max="255" value="128">
          <span>(0-255)</span>
        </div>
        
        <div class="setting-row">
          <label>PWM Duty:</label>
          <input type="number" id="dutyCycle" min="1" max="99" value="50">
          <span>% (1-99)</span>
        </div>
        
        <div class="setting-row">
          <label>Pulse Width:</label>
          <input type="number" id="pulseWidth" min="1" max="10000" value="100">
          <span>ms (1-10000)</span>
        </div>
        
        <div class="setting-row">
          <button id="signalToggle" onclick="toggleSignal()">Start Signal</button>
          <button class="pulse" onclick="sendSinglePulse()">Single Pulse</button>
          <button onclick="applySignalSettings()">Apply Settings</button>
        </div>
      </div>
    </div>
    
    <canvas id="oscilloscope"></canvas>
    
    <div class="legend">
      <p><strong>Oscilloscope Channels:</strong></p>
      <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; margin-top: 8px;">
        <span style="color: #ff6384;">CH1: GPIO34</span>
        <span style="color: #36a2eb;">CH2: GPIO35</span>
        <span style="color: #ffce56;">CH3: GPIO32</span>
        <span style="color: #4bc0c0;">CH4: GPIO33</span>
        <span style="color: #9966ff;">CH5: GPIO36</span>
        <span style="color: #ff9f40;">CH6: GPIO39</span>
      </div>
      <p><strong>Signal Output:</strong> GPIO27 (DAC)</p>
    </div>
    
    <script src="/chart.js"></script>
    <script>
      let ctx = document.getElementById('oscilloscope').getContext('2d');
      let chart;
      let continuousMode = true;
      let isCapturing = false;
      let updateInterval;
      let signalEnabled = false;
      let currentSettings = {
        numSamples: 100,
        sampleRate: 100,
        channelDelay: 5,
        captureInterval: 50,
        webUpdate: 500
      };
      let currentSignalSettings = {
        waveformType: 0,
        amplitude: 128,
        frequency: 1000,
        dutyCycle: 50,
        dcOffset: 128,
        pulseWidthMs: 100
      };

      const channelColors = [
        '#ff6384', '#36a2eb', '#ffce56', '#4bc0c0', '#9966ff', '#ff9f40'
      ];

      const presets = [
        {name: "High Speed", samples: 100, sampleRate: 10, channelDelay: 1, captureInterval: 20, webUpdate: 200},
        {name: "Balanced", samples: 200, sampleRate: 100, channelDelay: 5, captureInterval: 50, webUpdate: 500},
        {name: "High Resolution", samples: 500, sampleRate: 1000, channelDelay: 10, captureInterval: 200, webUpdate: 1000},
        {name: "Low Power", samples: 50, sampleRate: 5000, channelDelay: 20, captureInterval: 1000, webUpdate: 2000}
      ];

      const signalPresets = [
        {name: "1kHz Square", waveform: 1, amplitude: 255, frequency: 1000, dutyCycle: 50, dcOffset: 128},
        {name: "10kHz Sine", waveform: 2, amplitude: 200, frequency: 10000, dutyCycle: 50, dcOffset: 128},
        {name: "PWM 25%", waveform: 4, amplitude: 255, frequency: 1000, dutyCycle: 25, dcOffset: 0},
        {name: "Test Signal", waveform: 1, amplitude: 128, frequency: 100, dutyCycle: 50, dcOffset: 64},
        {name: "DC 1.65V", waveform: 0, amplitude: 128, frequency: 0, dutyCycle: 0, dcOffset: 128}
      ];

      function initChart() {
        if (typeof Chart === 'undefined') {
          console.error('Chart.js not loaded!');
          document.getElementById('connectionStatus').textContent = 'Chart.js Load Error';
          return;
        }

        chart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: Array.from({ length: currentSettings.numSamples }, (_, i) => i),
            datasets: channelColors.map((color, index) => ({
              label: `CH${index + 1}`,
              data: Array(currentSettings.numSamples).fill(0),
              borderColor: color,
              backgroundColor: color + '20',
              fill: false,
              tension: 0.1,
              pointRadius: 0,
              borderWidth: 2
            }))
          },
          options: {
            animation: false,
            responsive: true,
            maintainAspectRatio: false,
            interaction: { intersect: false, mode: 'index' },
            scales: {
              x: {
                title: { display: true, text: 'Sample Number', color: 'white' },
                grid: { color: '#444' },
                ticks: { color: 'white' }
              },
              y: {
                beginAtZero: true,
                max: 4095,
                title: { display: true, text: 'ADC Value (0-4095)', color: 'white' },
                grid: { color: '#444' },
                ticks: { color: 'white' }
              }
            },
            plugins: {
              legend: { labels: { color: 'white', usePointStyle: true } },
              tooltip: { backgroundColor: 'rgba(0,0,0,0.8)', titleColor: 'white', bodyColor: 'white' }
            }
          }
        });
        
        document.getElementById('connectionStatus').textContent = 'Connected';
        startUpdates();
      }

      function startUpdates() {
        if (updateInterval) clearInterval(updateInterval);
        updateInterval = setInterval(() => {
          if (continuousMode && !isCapturing) {
            fetchData();
          }
          updateSignalStatus();
        }, currentSettings.webUpdate);
      }

      async function fetchData() {
        if (isCapturing) return;
        
        try {
          isCapturing = true;
          const response = await fetch('/data');
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          
          const json = await response.json();
          updateChart(json);
          if (document.getElementById('connectionStatus').textContent !== 'Connected') {
            document.getElementById('connectionStatus').textContent = 'Connected';
          }
        } catch (error) {
          console.error('Error:', error);
          document.getElementById('connectionStatus').textContent = 'Disconnected';
        } finally {
          isCapturing = false;
        }
      }

      function toggleMode() {
        continuousMode = !continuousMode;
        document.getElementById('modeStatus').textContent = continuousMode ? 'Continuous' : 'Snapshot';
        
        const mode = continuousMode ? 'continuous' : 'snapshot';
        fetch(`/setMode?mode=${mode}`)
          .then(response => response.ok && console.log(`Mode: ${mode}`))
          .catch(error => console.error('Error setting mode:', error));
      }

      function captureWaveform() {
        fetchData();
      }

      function clearChart() {
        if (chart) {
          chart.data.datasets.forEach(dataset => {
            dataset.data = Array(currentSettings.numSamples).fill(0);
          });
          chart.update('none');
        }
      }

      function toggleSettings() {
        const panel = document.getElementById('settingsPanel');
        panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
      }

      function toggleSignalSettings() {
        const panel = document.getElementById('signalPanel');
        panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
      }

      function applyPreset(index) {
        const preset = presets[index];
        document.getElementById('numSamples').value = preset.samples;
        document.getElementById('sampleRate').value = preset.sampleRate;
        document.getElementById('channelDelay').value = preset.channelDelay;
        document.getElementById('captureInterval').value = preset.captureInterval;
        document.getElementById('webUpdate').value = preset.webUpdate;
        applySettings();
      }

      function applySignalPreset(index) {
        const preset = signalPresets[index];
        document.getElementById('waveformType').value = preset.waveform;
        document.getElementById('amplitude').value = preset.amplitude;
        document.getElementById('frequency').value = preset.frequency;
        document.getElementById('dutyCycle').value = preset.dutyCycle;
        document.getElementById('dcOffset').value = preset.dcOffset;
        applySignalSettings();
      }

      function resetToDefaults() {
        applyPreset(1); // Balanced preset
      }

      async function applySettings() {
        const settings = {
          numSamples: parseInt(document.getElementById('numSamples').value),
          sampleRate: parseInt(document.getElementById('sampleRate').value),
          channelDelay: parseInt(document.getElementById('channelDelay').value),
          captureInterval: parseInt(document.getElementById('captureInterval').value),
          webUpdate: parseInt(document.getElementById('webUpdate').value)
        };

        try {
          const response = await fetch('/setConfig', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(settings)
          });

          if (response.ok) {
            currentSettings = settings;
            updateStatusDisplay();
            
            // Update chart labels and data arrays
            chart.data.labels = Array.from({ length: settings.numSamples }, (_, i) => i);
            chart.data.datasets.forEach(dataset => {
              dataset.data = Array(settings.numSamples).fill(0);
            });
            chart.update();
            
            startUpdates(); // Restart with new timing
            console.log('Settings applied successfully');
          } else {
            console.error('Failed to apply settings');
          }
        } catch (error) {
          console.error('Error applying settings:', error);
        }
      }

      async function applySignalSettings() {
        const settings = {
          waveformType: parseInt(document.getElementById('waveformType').value),
          amplitude: parseInt(document.getElementById('amplitude').value),
          frequency: parseInt(document.getElementById('frequency').value),
          dutyCycle: parseInt(document.getElementById('dutyCycle').value),
          dcOffset: parseInt(document.getElementById('dcOffset').value),
          pulseWidthMs: parseInt(document.getElementById('pulseWidth').value)
        };

        try {
          const response = await fetch('/setSignalConfig', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(settings)
          });

          if (response.ok) {
            currentSignalSettings = settings;
            console.log('Signal settings applied successfully');
            updateSignalStatus();
          } else {
            console.error('Failed to apply signal settings');
          }
        } catch (error) {
          console.error('Error applying signal settings:', error);
        }
      }

      async function toggleSignal() {
        try {
          const response = await fetch('/toggleSignal', { method: 'POST' });
          if (response.ok) {
            const result = await response.json();
            signalEnabled = result.enabled;
            updateSignalToggleButton();
            updateSignalStatus();
          }
        } catch (error) {
          console.error('Error toggling signal:', error);
        }
      }

      async function sendSinglePulse() {
        try {
          const response = await fetch('/singlePulse', { method: 'POST' });
          if (response.ok) {
            console.log('Single pulse sent');
            setTimeout(updateSignalStatus, 100); // Update status after pulse
          }
        } catch (error) {
          console.error('Error sending pulse:', error);
        }
      }

      function updateSignalToggleButton() {
        const button = document.getElementById('signalToggle');
        if (signalEnabled) {
          button.textContent = 'Stop Signal';
          button.className = 'signal-on';
        } else {
          button.textContent = 'Start Signal';
          button.className = '';
        }
      }

      async function updateSignalStatus() {
        try {
          const response = await fetch('/getSignalStatus');
          if (response.ok) {
            const status = await response.json();
            signalEnabled = status.enabled;
            
            const statusEl = document.getElementById('signalStatus');
            const stateEl = document.getElementById('signalState');
            const infoEl = document.getElementById('signalInfo');
            
            if (status.enabled) {
              statusEl.className = 'signal-status active';
              stateEl.textContent = 'ON';
              
              const waveforms = ['DC', 'Square', 'Sine', 'Triangle', 'PWM'];
              const voltage = (status.amplitude * 3.3 / 255).toFixed(2);
              
              if (status.waveformType === 0) {
                infoEl.textContent = `DC ${voltage}V`;
              } else if (status.waveformType === 4) {
                infoEl.textContent = `PWM ${status.frequency}Hz ${status.dutyCycle}% (${voltage}V)`;
              } else {
                infoEl.textContent = `${waveforms[status.waveformType]} ${status.frequency}Hz (${voltage}V)`;
              }
            } else {
              statusEl.className = 'signal-status';
              stateEl.textContent = 'OFF';
              infoEl.textContent = 'No Signal';
            }
            
            updateSignalToggleButton();
          }
        } catch (error) {
          console.error('Error fetching signal status:', error);
        }
      }

      function updateStatusDisplay() {
        document.getElementById('currentSamples').textContent = currentSettings.numSamples;
        document.getElementById('currentRate').textContent = currentSettings.sampleRate + 'µs';
      }

      async function fetchCurrentConfig() {
        try {
          const response = await fetch('/getConfig');
          if (response.ok) {
            const config = await response.json();
            currentSettings = config;
            
            // Update UI inputs
            document.getElementById('numSamples').value = config.numSamples;
            document.getElementById('sampleRate').value = config.sampleRate;
            document.getElementById('channelDelay').value = config.channelDelay;
            document.getElementById('captureInterval').value = config.captureInterval;
            document.getElementById('webUpdate').value = config.webUpdate;
            
            updateStatusDisplay();
          }
        } catch (error) {
          console.error('Error fetching config:', error);
        }
      }

      async function fetchCurrentSignalConfig() {
        try {
          const response = await fetch('/getSignalConfig');
          if (response.ok) {
            const config = await response.json();
            currentSignalSettings = config;
            
            // Update UI inputs
            document.getElementById('waveformType').value = config.waveformType;
            document.getElementById('amplitude').value = config.amplitude;
            document.getElementById('frequency').value = config.frequency;
            document.getElementById('dutyCycle').value = config.dutyCycle;
            document.getElementById('dcOffset').value = config.dcOffset;
            document.getElementById('pulseWidth').value = config.pulseWidthMs;
          }
        } catch (error) {
          console.error('Error fetching signal config:', error);
        }
      }

      function updateChart(data) {
        if (!chart || !data.channels || !Array.isArray(data.channels)) return;

        chart.data.datasets.forEach((dataset, i) => {
          if (i < data.channels.length && Array.isArray(data.channels[i])) {
            dataset.data = data.channels[i];
          }
        });
        
        chart.update('none');
      }

      window.addEventListener('load', function() {
        setTimeout(() => {
          Promise.all([fetchCurrentConfig(), fetchCurrentSignalConfig()]).then(() => {
            initChart();
            setTimeout(() => {
              fetchData();
              updateSignalStatus();
            }, 1000);
          });
        }, 100);
      });
    </script>
  </body>
  </html>
  )rawliteral";